import{_ as e}from"./BV7Yc4PX.js";import{c as t,w as c,o as i,a,b as s}from"./B1kHp8qp.js";import"./8oskhlv7.js";const d={__name:"javascript-array-evolution-performance",setup(p){const n={title:"[译] 深入 JavaScript 数组：进化与性能",description:"深入 JavaScript 数组：进化与性能",keywords:"翻译,JavaScript",pathname:"javascript-array-evolution-performance",translation:{author:"Paul Shan",social:"http://voidcanvas.com/author/paulshan/",from:"http://voidcanvas.com/javascript-array-evolution-performance/"},create_time:"2017-09-12",prev:{title:"[译] 极速渲染引擎 WebRender 揭秘",pathname:"firefox-webrender"},next:{title:"ArrayBuffer and TypedArray in ES2015",pathname:"es2015-arraybuffer"}};return(o,l)=>{const r=e;return i(),t(r,{data:n},{default:c(()=>[...l[0]||(l[0]=[a("p",null,"正式开始前需要声明，本文并不是要讲解 JavaScript 数组基础知识，也不会涉及语法和使用案例。本文讲得更多的是内存、优化、语法差异、性能、近来的演进。",-1),a("p",null,"在使用 JavaScript 前，我对 C、C++、C# 这些已经颇为熟悉。与许多 C/C++ 开发者一样，JavaScript 给我的第一印象并不好。",-1),a("p",null,[a("code",null,"Array"),s(" 是主要原因之一。JavaScript 数组不是连续（contiguous）的，其实现类似哈希映射（hash-maps）或字典（dictionaries）。我觉得这有点像是一门 B 级语言，数组实现根本不恰当。自那以后，JavaScript 和我对它的理解都发生了变化，很多变化。")],-1),a("h2",null,"为什么说 JavaScript 数组不是真正的数组",-1),a("p",null,[s("在聊 JavaScript 之前，先讲讲 "),a("code",null,"Array"),s(" 是什么。")],-1),a("p",null,[s("数组是一串连续的内存位置，用来保存某些值。注意重点，“连续”（"),a("code",null,"continuous"),s("，或 "),a("code",null,"contiguous"),s("），这很重要。")],-1),a("p",null,[a("a",{href:"http://p0.qhimg.com/t013e8a7ea0ed65a53e.png",target:"_blank",rel:"noopener"},[a("img",{loading:"lazy",src:"https://p0.ssl.qhimg.com/t013e8a7ea0ed65a53e.png",alt:"数组内存示意图"})])],-1),a("p",null,"上图展示了数组在内存中存储方式。这个数组保存了 4 个元素，每个元素 4 字节。加起来总共占用了 16 字节的内存区。",-1),a("p",null,[s("假设我们声明了 "),a("code",null,"tinyInt arr[4];"),s("，分配到的内存区的地址从 "),a("code",null,"1201"),s(" 开始。一旦需要读取 "),a("code",null,"arr[2]"),s("，只需要通过数学计算拿到 "),a("code",null,"arr[2]"),s(" 的地址即可。计算 "),a("code",null,"1201 + (2 X 4)"),s("，直接从 "),a("code",null,"1209"),s(" 开始读取即可。")],-1),a("p",null,[a("a",{href:"http://res.cloudinary.com/dqubepfgb/image/upload/v1504384650/old-array-js_o8ufwz.png",target:"_blank",rel:"noopener"},[a("img",{loading:"lazy",src:"https://p0.ssl.qhimg.com/t0108bfb507aa331fad.png",alt:"javascript 链表"})])],-1),a("p",null,[s("JavaScript 中的数据是哈希映射，可以使用不同的数据结构来实现，如链表。所以，如果在 JavaScript 中声明一个数组 "),a("code",null,"var arr = new Array(4)"),s("，计算机将生成类似上图的结构。如果程序需要读取 "),a("code",null,"arr[2]"),s("，则需要从 "),a("code",null,"1201"),s(" 开始遍历寻址。")],-1),a("p",null,"以上就是 JavaScript 数组与真实数组的不同之处。显而易见，数学计算比遍历链表快。就长数组而言，情况尤其如此。",-1),a("h2",null,"JavaScript 数组的进化",-1),a("p",null,"不知你是否记得我们对朋友入手的 256MB 内存的电脑羡慕得要死的日子？而今天，8GB 内存遍地都是。",-1),a("p",null,"与此类似，JavaScript 这门语言也进化了不少。从 V8、SpiderMonkey 到 TC39 和与日俱增的 Web 用户，巨大的努力已经使 JavaScript 成为世界级必需品。一旦有了庞大的用户基础，性能提升自然是硬需求。",-1),a("p",null,[s("实际上，现代 JavaScript 引擎是会给数组分配连续内存的 —— 如果数组是同质的（所有元素类型相同）。优秀的程序员总会保证数组同质，以便 JIT（即时编译器）能够使用 "),a("code",null,"c"),s(" 编译器式的计算方法读取元素。")],-1),a("p",null,"不过，一旦你想要在某个同质数组中插入一个其他类型的元素，JIT 将解构整个数组，并按照旧有的方式重新创建。",-1),a("p",null,[s("因此，如果你的代码写得不太糟，JavaScript "),a("code",null,"Array"),s(" 对象在幕后依然保持着真正的数组形式，这对现代 JS 开发者来说极为重要。")],-1),a("p",null,[s("此外，数组跟随 ES2015/ES6 有了更多的演进。TC39 决定引入类型化数组（Typed Arrays），于是我们就有了 "),a("code",null,"ArrayBuffer"),s("。")],-1),a("p",null,[a("code",null,"ArrayBuffer"),s(" 提供一块连续内存供我们随意操作。然而，直接操作内存还是太复杂、偏底层。于是便有了处理 ArrayBuffer 的视图（View）。目前已有一些可用视图，未来还会有更多加入。")],-1),a("pre",null,[a("code",{class:"hljs lang-javascript"},[a("span",{class:"hljs-keyword"},"var"),s(" buffer = "),a("span",{class:"hljs-keyword"},"new"),s(),a("span",{class:"hljs-title class_"},"ArrayBuffer"),s("("),a("span",{class:"hljs-number"},"8"),s(`);
`),a("span",{class:"hljs-keyword"},"var"),s(" view   = "),a("span",{class:"hljs-keyword"},"new"),s(),a("span",{class:"hljs-title class_"},"Int32Array"),s(`(buffer);
view[`),a("span",{class:"hljs-number"},"0"),s("] = "),a("span",{class:"hljs-number"},"100"),s(`;
`)])],-1),a("p",null,[s("了解更多关于类型化数组（Typed Arrays）的知识，请访问 "),a("a",{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays",target:"_blank",rel:"noopener"},"MDN 文档"),s("。")],-1),a("p",null,[s("高性能、高效率的类型化数组在 WebGL 之后被引入。WebGL 工作者遇到了极大的性能问题，即如何高效处理二进制数据。另外，你也可以使用 "),a("a",{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer",target:"_blank",rel:"noopener"},"SharedArrayBuffer"),s(" 在多个 Web Worker 进程之间共享数据，以提升性能。")],-1),a("p",null,[s("从简单的哈希映射到现在的 "),a("code",null,"SharedArrayBuffer"),s("，这相当棒吧？")],-1),a("h2",null,"旧式数组 vs 类型化数组：性能",-1),a("p",null,[s("前面已经讨论了 JavaScript 数组的演进，现在来测试现代数组到底能给我们带来多大收益。下面是我在 Mac 上使用 "),a("code",null,"Node.js 8.4.0"),s(" 进行的一些微型测试结果。")],-1),a("h3",null,"旧式数组：插入",-1),a("pre",null,[a("code",{class:"hljs lang-javascript"},[a("span",{class:"hljs-keyword"},"var"),s(),a("span",{class:"hljs-variable constant_"},"LIMIT"),s(" = "),a("span",{class:"hljs-number"},"10000000"),s(`;
`),a("span",{class:"hljs-keyword"},"var"),s(" arr = "),a("span",{class:"hljs-keyword"},"new"),s(),a("span",{class:"hljs-title class_"},"Array"),s("("),a("span",{class:"hljs-variable constant_"},"LIMIT"),s(`);
`),a("span",{class:"hljs-variable language_"},"console"),s("."),a("span",{class:"hljs-title function_"},"time"),s("("),a("span",{class:"hljs-string"},'"Array insertion time"'),s(`);
`),a("span",{class:"hljs-keyword"},"for"),s(" ("),a("span",{class:"hljs-keyword"},"var"),s(" i = "),a("span",{class:"hljs-number"},"0"),s("; i < "),a("span",{class:"hljs-variable constant_"},"LIMIT"),s(`; i++) {
arr[i] = i;
}
`),a("span",{class:"hljs-variable language_"},"console"),s("."),a("span",{class:"hljs-title function_"},"timeEnd"),s("("),a("span",{class:"hljs-string"},'"Array insertion time"'),s(`);
`)])],-1),a("p",null,[a("strong",null,[s("用时："),a("em",null,"55ms")])],-1),a("h3",null,"Typed Array：插入",-1),a("pre",null,[a("code",{class:"hljs lang-javascript"},[a("span",{class:"hljs-keyword"},"var"),s(),a("span",{class:"hljs-variable constant_"},"LIMIT"),s(" = "),a("span",{class:"hljs-number"},"10000000"),s(`;
`),a("span",{class:"hljs-keyword"},"var"),s(" buffer = "),a("span",{class:"hljs-keyword"},"new"),s(),a("span",{class:"hljs-title class_"},"ArrayBuffer"),s("("),a("span",{class:"hljs-variable constant_"},"LIMIT"),s(" * "),a("span",{class:"hljs-number"},"4"),s(`);
`),a("span",{class:"hljs-keyword"},"var"),s(" arr = "),a("span",{class:"hljs-keyword"},"new"),s(),a("span",{class:"hljs-title class_"},"Int32Array"),s(`(buffer);
`),a("span",{class:"hljs-variable language_"},"console"),s("."),a("span",{class:"hljs-title function_"},"time"),s("("),a("span",{class:"hljs-string"},'"ArrayBuffer insertion time"'),s(`);
`),a("span",{class:"hljs-keyword"},"for"),s(" ("),a("span",{class:"hljs-keyword"},"var"),s(" i = "),a("span",{class:"hljs-number"},"0"),s("; i < "),a("span",{class:"hljs-variable constant_"},"LIMIT"),s(`; i++) {
arr[i] = i;
}
`),a("span",{class:"hljs-variable language_"},"console"),s("."),a("span",{class:"hljs-title function_"},"timeEnd"),s("("),a("span",{class:"hljs-string"},'"ArrayBuffer insertion time"'),s(`);
`)])],-1),a("p",null,[a("strong",null,[s("用时："),a("em",null,"52ms")])],-1),a("p",null,[s("擦，我看到了什么？旧式数组和 ArrayBuffer 的性能不相上下？不不不。请记住，前面提到过，现代编译器已经智能化，能够将元素类型相同的传统数组在内部转换成内存连续的数组。第一个例子正是如此。尽管使用了 "),a("code",null,"new Array(LIMIT)"),s("，数组实际依然以现代数组形式存在。")],-1),a("p",null,"接着修改第一例子，将数组改成异构型（元素类型不完全一致）的，来看看是否存在性能差异。",-1),a("h3",null,"旧式数组：插入（异构）",-1),a("pre",null,[a("code",{class:"hljs lang-javascript"},[a("span",{class:"hljs-keyword"},"var"),s(),a("span",{class:"hljs-variable constant_"},"LIMIT"),s(" = "),a("span",{class:"hljs-number"},"10000000"),s(`;
`),a("span",{class:"hljs-keyword"},"var"),s(" arr = "),a("span",{class:"hljs-keyword"},"new"),s(),a("span",{class:"hljs-title class_"},"Array"),s("("),a("span",{class:"hljs-variable constant_"},"LIMIT"),s(`);
arr.`),a("span",{class:"hljs-title function_"},"push"),s("({"),a("span",{class:"hljs-attr"},"a"),s(": "),a("span",{class:"hljs-number"},"22"),s(`});
`),a("span",{class:"hljs-variable language_"},"console"),s("."),a("span",{class:"hljs-title function_"},"time"),s("("),a("span",{class:"hljs-string"},'"Array insertion time"'),s(`);
`),a("span",{class:"hljs-keyword"},"for"),s(" ("),a("span",{class:"hljs-keyword"},"var"),s(" i = "),a("span",{class:"hljs-number"},"0"),s("; i < "),a("span",{class:"hljs-variable constant_"},"LIMIT"),s(`; i++) {
arr[i] = i;
}
`),a("span",{class:"hljs-variable language_"},"console"),s("."),a("span",{class:"hljs-title function_"},"timeEnd"),s("("),a("span",{class:"hljs-string"},'"Array insertion time"'),s(`);
`)])],-1),a("p",null,[a("strong",null,[s("用时："),a("em",null,"1207ms")])],-1),a("p",null,[s("改变发生在第 3 行，添加一条语句，将数组变为异构类型。其余代码保持不变。性能差异表现出来了，"),a("code",null,"慢了 22 倍"),s("。")],-1),a("h3",null,"旧式数组：读取",-1),a("pre",null,[a("code",{class:"hljs lang-javascript"},[a("span",{class:"hljs-keyword"},"var"),s(),a("span",{class:"hljs-variable constant_"},"LIMIT"),s(" = "),a("span",{class:"hljs-number"},"10000000"),s(`;
`),a("span",{class:"hljs-keyword"},"var"),s(" arr = "),a("span",{class:"hljs-keyword"},"new"),s(),a("span",{class:"hljs-title class_"},"Array"),s("("),a("span",{class:"hljs-variable constant_"},"LIMIT"),s(`);
arr.`),a("span",{class:"hljs-title function_"},"push"),s("({"),a("span",{class:"hljs-attr"},"a"),s(": "),a("span",{class:"hljs-number"},"22"),s(`});
`),a("span",{class:"hljs-keyword"},"for"),s(" ("),a("span",{class:"hljs-keyword"},"var"),s(" i = "),a("span",{class:"hljs-number"},"0"),s("; i < "),a("span",{class:"hljs-variable constant_"},"LIMIT"),s(`; i++) {
arr[i] = i;
}
`),a("span",{class:"hljs-keyword"},"var"),s(` p;
`),a("span",{class:"hljs-variable language_"},"console"),s("."),a("span",{class:"hljs-title function_"},"time"),s("("),a("span",{class:"hljs-string"},'"Array read time"'),s(`);
`),a("span",{class:"hljs-keyword"},"for"),s(" ("),a("span",{class:"hljs-keyword"},"var"),s(" i = "),a("span",{class:"hljs-number"},"0"),s("; i < "),a("span",{class:"hljs-variable constant_"},"LIMIT"),s(`; i++) {
`),a("span",{class:"hljs-comment"},"//arr[i] = i;"),s(`
p = arr[i];
}
`),a("span",{class:"hljs-variable language_"},"console"),s("."),a("span",{class:"hljs-title function_"},"timeEnd"),s("("),a("span",{class:"hljs-string"},'"Array read time"'),s(`);
`)])],-1),a("p",null,[a("strong",null,[s("用时："),a("em",null,"196ms")])],-1),a("h3",null,"Typed Array：读取",-1),a("pre",null,[a("code",{class:"hljs lang-javascript"},[a("span",{class:"hljs-keyword"},"var"),s(),a("span",{class:"hljs-variable constant_"},"LIMIT"),s(" = "),a("span",{class:"hljs-number"},"10000000"),s(`;
`),a("span",{class:"hljs-keyword"},"var"),s(" buffer = "),a("span",{class:"hljs-keyword"},"new"),s(),a("span",{class:"hljs-title class_"},"ArrayBuffer"),s("("),a("span",{class:"hljs-variable constant_"},"LIMIT"),s(" * "),a("span",{class:"hljs-number"},"4"),s(`);
`),a("span",{class:"hljs-keyword"},"var"),s(" arr = "),a("span",{class:"hljs-keyword"},"new"),s(),a("span",{class:"hljs-title class_"},"Int32Array"),s(`(buffer);
`),a("span",{class:"hljs-variable language_"},"console"),s("."),a("span",{class:"hljs-title function_"},"time"),s("("),a("span",{class:"hljs-string"},'"ArrayBuffer insertion time"'),s(`);
`),a("span",{class:"hljs-keyword"},"for"),s(" ("),a("span",{class:"hljs-keyword"},"var"),s(" i = "),a("span",{class:"hljs-number"},"0"),s("; i < "),a("span",{class:"hljs-variable constant_"},"LIMIT"),s(`; i++) {
arr[i] = i;
}
`),a("span",{class:"hljs-variable language_"},"console"),s("."),a("span",{class:"hljs-title function_"},"time"),s("("),a("span",{class:"hljs-string"},'"ArrayBuffer read time"'),s(`);
`),a("span",{class:"hljs-keyword"},"for"),s(" ("),a("span",{class:"hljs-keyword"},"var"),s(" i = "),a("span",{class:"hljs-number"},"0"),s("; i < "),a("span",{class:"hljs-variable constant_"},"LIMIT"),s(`; i++) {
`),a("span",{class:"hljs-keyword"},"var"),s(` p = arr[i];
}
`),a("span",{class:"hljs-variable language_"},"console"),s("."),a("span",{class:"hljs-title function_"},"timeEnd"),s("("),a("span",{class:"hljs-string"},'"ArrayBuffer read time"'),s(`);
`)])],-1),a("p",null,[a("strong",null,[s("用时："),a("em",null,"27ms")])],-1),a("h2",null,"结论",-1),a("p",null,[s("类型化数组的引入是 JavaScript 发展历程中的一大步。Int8Array，Uint8Array，Uint8ClampedArray，Int16Array，Uint16Array，Int32Array，Uint32Array，Float32Array，Float64Array，这些是类型化数组视图，使用原生字节序（与本机相同）。我们还可以使用 "),a("a",{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView",target:"_blank",rel:"noopener"},"DataView"),s(" 创建自定义视图窗口。希望未来会有更多帮助我们轻松操作 ArrayBuffer 的 DataView 库。")],-1),a("p",null,"JavaScript 数组的演进非常 nice。现在它们速度快、效率高、健壮，在内存分配时也足够智能。",-1),a("h2",null,"相关文章",-1),a("ol",null,[a("li",null,[a("p",null,[a("a",{href:"http://voidcanvas.com/is-javascript-really-interpreted-or-compiled-language/",target:"_blank",rel:"noopener",title:"Is JavaScript really interpreted or compiled language?"},"Is JavaScript really interpreted or compiled language?")])]),a("li",null,[a("p",null,[a("a",{href:"http://voidcanvas.com/create-filter-an-array-to-have-only-unique-elements-in-it/",target:"_blank",rel:"noopener",title:"Create / filter an array to have only unique elements in it"},"Create / filter an array to have only unique elements in it")])]),a("li",null,[a("p",null,[a("a",{href:"http://voidcanvas.com/object-entries-object-values-ecmascript2017-es8-examples/",target:"_blank",rel:"noopener",title:"Object.entries() & Object.values() in EcmaScript2017 (ES8) with examples"},"Object.entries() & Object.values() in EcmaScript2017 (ES8) with examples")])]),a("li",null,[a("p",null,[a("a",{href:"http://voidcanvas.com/import-vs-require/",target:"_blank",rel:"noopener",title:"import vs require – ESM & commonJs module differences"},"import vs require – ESM & commonJs module differences")])]),a("li",null,[a("p",null,[a("a",{href:"http://voidcanvas.com/deep-dive-ember-routers-ember-js-tutorial-part-5/",target:"_blank",rel:"noopener",title:"A deep dive into ember routers – Ember.js Tutorial part 5"},"A deep dive into ember routers – Ember.js Tutorial part 5")])]),a("li",null,[a("p",null,[a("a",{href:"http://voidcanvas.com/myths-facts-javascript/",target:"_blank",rel:"noopener",title:"Myths and Facts of JavaScript"},"Myths and Facts of JavaScript")])])],-1)])]),_:1})}}};export{d as default};
