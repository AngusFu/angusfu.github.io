import{_ as n}from"./CaNb7KN_.js";import{c as i,w as o,o as p,a as e,b as t}from"./Du-K4N_a.js";const y={__name:"javascript-weekly-307",setup(u){const r={title:"JavaScript Weekly 307 阅读笔记",description:"JavaScript Weekly 307 阅读笔记",keywords:"原创,JavaScript,阅读笔记",pathname:"javascript-weekly-307",translation:null,create_time:"2016-10-28",prev:{title:"使用 jQuery.ajax 上传带文件的表单",pathname:"jquery-ajax-formdata"},next:{title:"关于 setImmediate",pathname:"js-set-immediate"}};return(s,l)=>{const a=n;return p(),i(a,{data:r},{default:o(()=>[...l[0]||(l[0]=[e("h2",null,"js 编写简单的 compiler",-1),e("ul",null,[e("li",null,[e("a",{href:"https://medium.com/@kosamari/how-to-be-a-compiler-make-a-compiler-with-javascript-4a8a13d473b4#.ybwdnaudk",target:"_blank",rel:"noopener"},"How to Make a (Very) Simple Compiler with JS")])],-1),e("p",null,[t("这个小小的 compiler 还挺简单，将简单的画图指令转换为 SVG 标记。文章作者写了一个 "),e("a",{href:"https://kosamari.github.io/sbn/",target:"_blank",rel:"noopener"},"demo"),t("，用来演示转换的整个过程，感觉不错，建议看看。")],-1),e("p",null,[t("之前也有人讲过一些，比如 github 上的 "),e("a",{href:"https://github.com/thejameskyle/the-super-tiny-compiler/",target:"_blank",rel:"noopener"},"the-super-tiny-compiler"),t("（有"),e("a",{href:"https://github.com/yyzl/the-super-tiny-compiler",target:"_blank",rel:"noopener"},"中文版"),t("），貌似还在 2016 年 JSConf 上讲过。又如我之前翻译的这个，《"),e("a",{href:"http://www.wemlion.com/2016/writing-a-lambda-calculus-interpreter-in-javascript/",target:"_blank",rel:"noopener"},"小两百行 JavaScript 打造 lambda 演算解释器"),t("》。")],-1),e("p",null,"其实，说到底还是几个步骤，简单的 compiler 实现起来大同小异。词法分析生成 token，句法分析生成 AST，然后转换 AST，最后遍历 AST 生成代码。",-1),e("p",null,"说到遍历 AST 生成代码，实际上，我们常用的 Babel、UglifyJS 等等这些都有用到。",-1),e("p",null,"想到几篇文章，可以看看：",-1),e("ul",null,[e("li",null,[e("p",null,[e("a",{href:"https://www.h5jun.com/post/code-coverage-with-babel-plugin.html",target:"_blank",rel:"noopener"},"Babel 插件开发与单元测试覆盖度检查")])]),e("li",null,[e("p",null,[e("a",{href:"https://www.h5jun.com/post/babel-for-es6-and-beyond.html",target:"_blank",rel:"noopener"},"Babel for ES6? And Beyond!")])]),e("li",null,[e("p",null,[e("a",{href:"https://segmentfault.com/a/1190000006851890",target:"_blank",rel:"noopener"},"可信前端之路-代码保护")])])],-1),e("h2",null,"Typed Array",-1),e("ul",null,[e("li",null,[e("a",{href:"https://codingbox.io/exploring-javascript-typed-arrays-c8fd4f8bd24f#.vp28u69i6",target:"_blank",rel:"noopener"},"Exploring JavaScript: Typed Arrays")])],-1),e("p",null,[t("关于 "),e("strong",null,"Typed Array 的浏览器支持"),t("，目前还存在以下问题：")],-1),e("ul",null,[e("li",null,"IE 9 不支持"),e("li",null,"IE10 (以及 IE 10&11 mobile) 不支持 Uint8ClampedArray"),e("li",null,"Safari 5.1 不支持 Float64Array"),e("li",null,"Firefox 14 以下没有 DataView"),e("li",null,"Safari 6 之前的版本, Typed Array 比 Array 对象还要慢"),e("li",null,"IE 10 中的 ArrayBuffer 没有 slice 方法")],-1),e("p",null,[e("strong",null,"Type Array 类型"),t("如下：")],-1),e("p",null,"| Type | 字节 | Web IDL type | C type | |:-----|:-----|:-------|:---------------|:---------| | Int8Array | 1 | byte | int8_t | | Uint8Array | 1 | 8-bit unsigned integer octet | uint8_t | | Uint8ClampedArray | 1 | 8-bit unsigned integer (clamped) octet | uint8_t | | Int16Array | 2 | 16-bit two’s complement signed integer short | int16_t | | Uint16Array | 2 | 16-bit unsigned integer unsigned short | uint16_t | | Int32Array | 4 | 32-bit two’s complement signed integer long | int32_t | | Uint32Array | 4 | 32-bit unsigned integer unsigned long | uint32_t | | Float32Array | 4 | 32-bit IEEE floating point number unrestricted float | float | | Float64Array | 8 | 64-bit IEEE floating point number unrestricted double | double |",-1)])]),_:1})}}};export{y as default};
