import{_ as o}from"./CaNb7KN_.js";import{c,w as t,o as r,a as s,b as l}from"./Du-K4N_a.js";const h={__name:"sandbox-code-evaluation",setup(p){const a={title:"[译] 手把手教你写一个 Javascript 框架：沙箱求值",description:"关于沙箱求值，ES6，Proxy，Symbol，WeakMap",keywords:"翻译,JavaScript,ES6",pathname:"sandbox-code-evaluation",translation:{author:"Bertalan Miklos",social:"https://blog.risingstack.com/author/bertalan/",from:"https://blog.risingstack.com/writing-a-javascript-framework-sandboxed-code-evaluation/"},create_time:"2016-11-18",prev:{title:"[译] 手把手教你写一个 Javascript 框架：项目结构",pathname:"nx-project-structure"},next:{title:"[译] 手把手教你写一个 Javascript 框架：执行调度",pathname:"execution-timing"}};return(i,n)=>{const e=o;return r(),c(e,{data:a},{default:t(()=>[...n[0]||(n[0]=[s("p",null,[s("strong",null,"本文是“编写 JavaScript 框架”系列的第三章。在本章中，我将介绍浏览器中对代码求值的几种不同方式及其存在的问题，也会介绍一种依赖 JavaScript 新特性的方法。")],-1),s("p",null,[l("本系列主要是如何开发一个开源的客户端框架，框架名为 NX。我将在本系列中分享框架编写过程中如何克服遇到的主要困难。对 NX 感兴趣的朋友可以点击 NX 项目"),s("a",{href:"http://nx-framework.com/",target:"_blank",rel:"noopener"},"主页"),l("查看。")],-1),s("p",null,"本系列章节如下：",-1),s("ul",null,[s("li",null,[s("a",{href:"/post/nx-project-structure/"},"项目结构（Project structuring）")]),s("li",null,[s("a",{href:"/post/execution-timing/"},"执行调度(Execution timing)")]),s("li",null,"沙箱求值（本章）"),s("li",null,[s("a",{href:"/post/data-bind-dirty-checking"},"数据绑定简介")]),s("li",null,[s("a",{href:"/post/es6-proxy-data-binding/"},"ES6 Proxy 实现数据绑定")]),s("li",null,"自定义元素"),s("li",null,"客户端路由")],-1),s("h2",null,"邪恶 eval",-1),s("blockquote",null,[s("p",null,[s("code",null,"eval()"),l(" 函数用来对字符串形式的 JavaScript 代码进行求值。")])],-1),s("p",null,[l("常见的代码求值方法是使用 "),s("code",null,"eval()"),l(" 函数。通过 "),s("code",null,"eval()"),l(" 执行的代码可以访问闭包和全局作用域，所以可能导致"),s("a",{href:"https://en.wikipedia.org/wiki/Code_injection",target:"_blank",rel:"noopener"},"代码注入(code injection)"),l("，正因此 "),s("code",null,"eval()"),l(" 成为 JavaScript 中最臭名昭著的特性之一。")],-1),s("p",null,[l("抛开上述缺点不说，"),s("code",null,"eval()"),l(" 在某些情况下还是很有用的。多数现代前端框架都需要 "),s("code",null,"eval()"),l(" 的这种功能，但是往往又因前述问题畏手畏脚。因此出现许多字符串求值方案，在沙箱而非全局作用域中进行操作。沙箱可以阻止代码访问与安全相关的数据，它通常是一个简单对象，用于替换代码中的全局对象。")],-1),s("h2",null,"常见做法",-1),s("p",null,[l("替代 "),s("code",null,"eval()"),l(" 最常见的方式是彻底重新实现。重新实现的过程由解析（parsing）、解释（interpreting）两步组成。首先由解析器创建"),s("a",{href:"https://en.wikipedia.org/wiki/Abstract_syntax_tree",target:"_blank",rel:"noopener"},"抽象语法树"),l("，然后由解释器遍历语法树，将其译为运行在沙箱中的代码。")],-1),s("p",null,[l("这种方案使用广泛，但可谓是杀鸡拿了把牛刀。放弃修补 "),s("code",null,"eval()"),l("，选择从零开始重写，带来的后果就是，许多 bug 蠢蠢欲动，准备伺机而出。而随着语言的升级更新，也不得不频繁修改源码。")],-1),s("h2",null,"另一种思路",-1),s("p",null,[s("a",{href:"http://nx-framework.com",target:"_blank",rel:"noopener"},"NX"),l(" 尽可能避免了重新实现代码，采用一个很小的库处理求值，该库使用了一些较可能少为人知的新特性。")],-1),s("p",null,[l("这一节逐步介绍这些特性，并使用它们解释用于代码求值的 "),s("a",{href:"https://github.com/RisingStack/nx-compile",target:"_blank",rel:"noopener"},"nx-compile"),l(" 库。这个库有一个名为 "),s("code",null,"compileCode()"),l(" 的函数，工作方式如下：")],-1),s("pre",null,[s("code",{class:"hljs lang-javascript"},[s("span",{class:"hljs-keyword"},"const"),l(" code = "),s("span",{class:"hljs-title function_"},"compileCode"),l("("),s("span",{class:"hljs-string"},"'return num1 + num2'"),l(`)

`),s("span",{class:"hljs-comment"},"// 控制台打印 17"),l(`
`),s("span",{class:"hljs-variable language_"},"console"),l("."),s("span",{class:"hljs-title function_"},"log"),l("("),s("span",{class:"hljs-title function_"},"code"),l("({"),s("span",{class:"hljs-attr"},"num1"),l(": "),s("span",{class:"hljs-number"},"10"),l(", "),s("span",{class:"hljs-attr"},"num2"),l(": "),s("span",{class:"hljs-number"},"7"),l(`}))

`),s("span",{class:"hljs-keyword"},"const"),l(" globalNum = "),s("span",{class:"hljs-number"},"12"),l(`  
`),s("span",{class:"hljs-keyword"},"const"),l(" otherCode = "),s("span",{class:"hljs-title function_"},"compileCode"),l("("),s("span",{class:"hljs-string"},"'return globalNum'"),l(`)

`),s("span",{class:"hljs-comment"},"// 访问全局作用域被禁止"),l(`
`),s("span",{class:"hljs-comment"},"// 控制台打印 undefined"),l(`
`),s("span",{class:"hljs-variable language_"},"console"),l("."),s("span",{class:"hljs-title function_"},"log"),l("("),s("span",{class:"hljs-title function_"},"otherCode"),l("({"),s("span",{class:"hljs-attr"},"num1"),l(": "),s("span",{class:"hljs-number"},"2"),l(", "),s("span",{class:"hljs-attr"},"num2"),l(": "),s("span",{class:"hljs-number"},"3"),l(`})) 
`)])],-1),s("p",null,[l("待到本文结束，我们会用不到 20 行的代码实现 "),s("code",null,"compileCode()"),l(" 函数。")],-1),s("h3",null,[s("code",null,"new Function()")],-1),s("blockquote",null,[s("p",null,"Function 构造函数用于创建新的 Function 对象。在 JavaScript 中，所有函数都是 Function 对象。")],-1),s("p",null,[l("Function 构造函数可以达到 "),s("code",null,"eval()"),l(" 同样的目的。"),s("code",null,"new Function(...args, 'funcBody')"),l(" 对传入的 "),s("code",null,"'funcBody'"),l(" 字符进行求值，并返回执行这段代码的函数。"),s("code",null,"new Function()"),l(" 与 "),s("code",null,"eval()"),l(" 的不同主要体现在以下两方面：")],-1),s("ul",null,[s("li",null,[s("p",null,[s("code",null,"new Function()"),l(" 方法只会对传入的代码求值一次。调用返回函数时，只会运行代码，而不会重新求值。")])]),s("li",null,[s("p",null,[s("code",null,"new Function()"),l(" 方法无法访问闭包中的本地变量；不过还是可以访问全局作用域。")])])],-1),s("pre",null,[s("code",{class:"hljs lang-javascript"},[s("span",{class:"hljs-keyword"},"function"),l(),s("span",{class:"hljs-title function_"},"compileCode"),l(" ("),s("span",{class:"hljs-params"},"src"),l(`) {  
  `),s("span",{class:"hljs-keyword"},"return"),l(),s("span",{class:"hljs-keyword"},"new"),l(),s("span",{class:"hljs-title class_"},"Function"),l(`(src)
} 
`)])],-1),s("p",null,[l("对我们来说，"),s("code",null,"new Function()"),l(" 要优于 "),s("code",null,"eval()"),l("。它性能更好，也更安全。不过要使其完全可用，还需要阻止其访问全局作用域。")],-1),s("h3",null,[s("code",null,"with"),l(" 关键词")],-1),s("blockquote",null,[s("p",null,[s("code",null,"with"),l(" 能够扩展声明的作用域链。")])],-1),s("p",null,[l("JavaScript 中，"),s("code",null,"with"),l(" 关键词较少露面。"),s("code",null,"with"),l(" 可以帮我们半沙箱化地执行代码。"),s("code",null,"with"),l(" 语句块首先会试着从传递的沙箱对象检索变量，如果没有找到，则会到闭包和全局作用域中寻找。前面说过，"),s("code",null,"new Function()"),l(" 能够阻止访问闭包中的变量，故现在只需考虑全局作用域的问题。")],-1),s("pre",null,[s("code",{class:"hljs lang-javascript"},[s("span",{class:"hljs-keyword"},"function"),l(),s("span",{class:"hljs-title function_"},"compileCode"),l(" ("),s("span",{class:"hljs-params"},"src"),l(`) {
  src = `),s("span",{class:"hljs-string"},"'with (sandbox) {'"),l(" + src + "),s("span",{class:"hljs-string"},"'}'"),l(`
  `),s("span",{class:"hljs-keyword"},"return"),l(),s("span",{class:"hljs-keyword"},"new"),l(),s("span",{class:"hljs-title class_"},"Function"),l("("),s("span",{class:"hljs-string"},"'sandbox'"),l(`, src)
}
`)])],-1),s("p",null,[l("在内部实现中，"),s("code",null,"with"),l(" 使用了 "),s("code",null,"in"),l(" 操作。对于语句块中的所有变量访问，都会使用 "),s("code",null,"variable in sandbox"),l(" 条件进行判断。若条件为真，则从沙箱对象中读取变量；否则会去全局变量中寻找变量。在 "),s("code",null,"with"),l(" 操作过程中，我们可以让 "),s("code",null,"variable in sandbox"),l(" 永远返回 true，这样就能阻止访问全局变量。")],-1),s("p",null,[s("img",{loading:"lazy",src:"https://s0.ssl.qhres2.com/static/fc3642ce6bdb875f.svg",alt:"Sandboxed code evaluation: Simple 'with' statement"})],-1),s("h3",null,"ES6 Proxy",-1),s("blockquote",null,[s("p",null,"Proxy 对象用于自定义 Object 的一些基本操作，如属性读取、赋值等行为。")],-1),s("p",null,[l("ES6 "),s("code",null,"Proxy"),l(" 封装对象，并定义一些 trap 函数，这些函数可以拦截该对象的基本操作行为。操作对象时，就会调用相应的 trap 函数。使用 "),s("code",null,"Proxy"),l(" 封装沙箱对象，定义一个 "),s("code",null,"has"),l(" 操作 trap，即可覆盖 "),s("code",null,"in"),l(" 操作符的默认行为。")],-1),s("pre",null,[s("code",{class:"hljs lang-javascript"},[s("span",{class:"hljs-keyword"},"function"),l(),s("span",{class:"hljs-title function_"},"compileCode"),l(" ("),s("span",{class:"hljs-params"},"src"),l(`) {
  src = `),s("span",{class:"hljs-string"},"'with (sandbox) {'"),l(" + src + "),s("span",{class:"hljs-string"},"'}'"),l(`
  `),s("span",{class:"hljs-keyword"},"const"),l(" code = "),s("span",{class:"hljs-keyword"},"new"),l(),s("span",{class:"hljs-title class_"},"Function"),l("("),s("span",{class:"hljs-string"},"'sandbox'"),l(`, src)

  `),s("span",{class:"hljs-keyword"},"return"),l(),s("span",{class:"hljs-keyword"},"function"),l(" ("),s("span",{class:"hljs-params"},"sandbox"),l(`) {
    `),s("span",{class:"hljs-keyword"},"const"),l(" sandboxProxy = "),s("span",{class:"hljs-keyword"},"new"),l(),s("span",{class:"hljs-title class_"},"Proxy"),l(`(sandbox, {has})
    `),s("span",{class:"hljs-keyword"},"return"),l(),s("span",{class:"hljs-title function_"},"code"),l(`(sandboxProxy)
  }
}

`),s("span",{class:"hljs-comment"},"// 用于拦截对 sandboxProxy 的 'in' 操作"),l(`
`),s("span",{class:"hljs-keyword"},"function"),l(),s("span",{class:"hljs-title function_"},"has"),l(" ("),s("span",{class:"hljs-params"},"target, key"),l(`) {
  `),s("span",{class:"hljs-keyword"},"return"),l(),s("span",{class:"hljs-literal"},"true"),l(`
}
`)])],-1),s("p",null,[l("上面的代码耍了 "),s("code",null,"with"),l(" 代码块一把。"),s("code",null,"variable in sandbox"),l(" 将永远为真，因为 "),s("code",null,"has"),l(" trap 函数总是返回 true。"),s("code",null,"width"),l(" 代码块中的代码永远无法访问全局对象。")],-1),s("p",null,[s("img",{loading:"lazy",src:"https://s0.ssl.qhres2.com/static/d9e40b9163d31b54.svg",alt:"Sandboxed code evaluation: 'with' statement and proxies"})],-1),s("h3",null,[s("code",null,"Symbol.unscopables")],-1),s("blockquote",null,[s("p",null,"Symbol 是一种唯一的、不可变的数据类型，可用作对象属性标识符。")],-1),s("p",null,[s("code",null,"Symbol.unscopables"),l(" 是一个驰名 symbol（"),s("a",{href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol",target:"_blank",rel:"noopener"},"Well-known symbol"),l("）。所谓“驰名 symbol”，实际上是一些内置 JavaScript "),s("code",null,"Symbol"),l("，代表某些内部语言行为。驰名 symbol 可以用于添加或重写一些行为，如数据的迭代、基本类型转换。")],-1),s("blockquote",null,[s("p",null,[l("Symbol.unscopables 用于指定对象的一些固有和继承属性，这些属性被排除在 "),s("code",null,"with"),l(" 所绑定的环境之外无法读取。")])],-1),s("p",null,[s("code",null,"Symbol.unscopables"),l(" 用于定义对象的 unscopable 属性（译者：不译，请自行领会）。"),s("code",null,"with"),l(" 声明中的沙箱对象的 unscopable 属性无法读取，这些属性会从闭包、全局作用域中读取。通常极少需要用到 "),s("code",null,"Symbol.unscopables"),l("。在"),s("a",{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/unscopables",target:"_blank",rel:"noopener"},"这里"),l("可以看到引入 "),s("code",null,"Symbol.unscopables"),l(" 的原因。")],-1),s("p",null,[s("img",{loading:"lazy",src:"https://s3.ssl.qhres2.com/static/f8e5bdb1ebf22a58.svg",alt:"Sandboxed code evaluation: 'with' statement and proxies. A security issue."})],-1),s("p",null,[l("我们为沙箱对象 proxy 添加一个"),s("code",null,"get"),l(" trap 函数，拦截检索 "),s("code",null,"Symbol.unscopables"),l(" 属性的行为，总是返回 undefined。这样会骗到 "),s("code",null,"with"),l(" 代码块，使其认为沙箱对象没有任何 unscopable 属性。")],-1),s("pre",null,[s("code",{class:"hljs lang-javascript"},[s("span",{class:"hljs-keyword"},"function"),l(),s("span",{class:"hljs-title function_"},"compileCode"),l(" ("),s("span",{class:"hljs-params"},"src"),l(`) {
  src = `),s("span",{class:"hljs-string"},"'with (sandbox) {'"),l(" + src + "),s("span",{class:"hljs-string"},"'}'"),l(`
  `),s("span",{class:"hljs-keyword"},"const"),l(" code = "),s("span",{class:"hljs-keyword"},"new"),l(),s("span",{class:"hljs-title class_"},"Function"),l("("),s("span",{class:"hljs-string"},"'sandbox'"),l(`, src)

  `),s("span",{class:"hljs-keyword"},"return"),l(),s("span",{class:"hljs-keyword"},"function"),l(" ("),s("span",{class:"hljs-params"},"sandbox"),l(`) {
    `),s("span",{class:"hljs-keyword"},"const"),l(" sandboxProxy = "),s("span",{class:"hljs-keyword"},"new"),l(),s("span",{class:"hljs-title class_"},"Proxy"),l(`(sandbox, {has, get})
    `),s("span",{class:"hljs-keyword"},"return"),l(),s("span",{class:"hljs-title function_"},"code"),l(`(sandboxProxy)
  }
}

`),s("span",{class:"hljs-keyword"},"function"),l(),s("span",{class:"hljs-title function_"},"has"),l(" ("),s("span",{class:"hljs-params"},"target, key"),l(`) {
  `),s("span",{class:"hljs-keyword"},"return"),l(),s("span",{class:"hljs-literal"},"true"),l(`
}

`),s("span",{class:"hljs-keyword"},"function"),l(),s("span",{class:"hljs-title function_"},"get"),l(" ("),s("span",{class:"hljs-params"},"target, key"),l(`) {
  `),s("span",{class:"hljs-keyword"},"if"),l(" (key === "),s("span",{class:"hljs-title class_"},"Symbol"),l("."),s("span",{class:"hljs-property"},"unscopables"),l(") "),s("span",{class:"hljs-keyword"},"return"),l(),s("span",{class:"hljs-literal"},"undefined"),l(`
  `),s("span",{class:"hljs-keyword"},"return"),l(` target[key]
} 
`)])],-1),s("p",null,[s("img",{loading:"lazy",src:"https://s0.ssl.qhres2.com/static/f2ac13b8fe932334.svg",alt:"Sandboxed code evaluation: 'with' statement and proxies. Has and get traps."})],-1),s("h3",null,"使用 WeakMap 进行缓存",-1),s("p",null,[l("代码现在是安全的，但性能还有可提升之处：可以看到，每次调用返回的函数时都会新建一个 "),s("code",null,"Proxy"),l("。通过缓存可以避免该问题，每次调用时，若沙箱对象相同，则可以使用同一个 "),s("code",null,"Proxy"),l(" 对象。")],-1),s("p",null,[l("Proxy 对象与沙箱对象一一对应，故可以单纯地将其作为沙箱对象的一个属性。不过，这可能会对外暴露代码实现细节。另外，若使用的是 "),s("code",null,"Object.freeze()"),l(" 冻结之后的不可变沙箱对象也不行。所以采用 "),s("code",null,"WeakMap"),l(" 才是更好的选择。")],-1),s("blockquote",null,[s("p",null,"WeakMap 对象是一个键值对集合。键为弱引用，必须是对象；值可以为任意类型。")],-1),s("p",null,[s("code",null,"WeakMap"),l(" 可在不直接扩展对象属性的情况下为该对象附加数据。通过 "),s("code",null,"WeakMap"),l(" 间接为沙箱对象添加缓存的 "),s("code",null,"Proxy"),l("。")],-1),s("pre",null,[s("code",{class:"hljs lang-javascript"},[s("span",{class:"hljs-keyword"},"const"),l(" sandboxProxies = "),s("span",{class:"hljs-keyword"},"new"),l(),s("span",{class:"hljs-title class_"},"WeakMap"),l(`()

`),s("span",{class:"hljs-keyword"},"function"),l(),s("span",{class:"hljs-title function_"},"compileCode"),l(" ("),s("span",{class:"hljs-params"},"src"),l(`) {
  src = `),s("span",{class:"hljs-string"},"'with (sandbox) {'"),l(" + src + "),s("span",{class:"hljs-string"},"'}'"),l(`
  `),s("span",{class:"hljs-keyword"},"const"),l(" code = "),s("span",{class:"hljs-keyword"},"new"),l(),s("span",{class:"hljs-title class_"},"Function"),l("("),s("span",{class:"hljs-string"},"'sandbox'"),l(`, src)

  `),s("span",{class:"hljs-keyword"},"return"),l(),s("span",{class:"hljs-keyword"},"function"),l(" ("),s("span",{class:"hljs-params"},"sandbox"),l(`) {
    `),s("span",{class:"hljs-keyword"},"if"),l(" (!sandboxProxies."),s("span",{class:"hljs-title function_"},"has"),l(`(sandbox)) {
      `),s("span",{class:"hljs-keyword"},"const"),l(" sandboxProxy = "),s("span",{class:"hljs-keyword"},"new"),l(),s("span",{class:"hljs-title class_"},"Proxy"),l(`(sandbox, {has, get})
      sandboxProxies.`),s("span",{class:"hljs-title function_"},"set"),l(`(sandbox, sandboxProxy)
    }
    `),s("span",{class:"hljs-keyword"},"return"),l(),s("span",{class:"hljs-title function_"},"code"),l("(sandboxProxies."),s("span",{class:"hljs-title function_"},"get"),l(`(sandbox))
  }
}

`),s("span",{class:"hljs-keyword"},"function"),l(),s("span",{class:"hljs-title function_"},"has"),l(" ("),s("span",{class:"hljs-params"},"target, key"),l(`) {
  `),s("span",{class:"hljs-keyword"},"return"),l(),s("span",{class:"hljs-literal"},"true"),l(`
}

`),s("span",{class:"hljs-keyword"},"function"),l(),s("span",{class:"hljs-title function_"},"get"),l(" ("),s("span",{class:"hljs-params"},"target, key"),l(`) {
  `),s("span",{class:"hljs-keyword"},"if"),l(" (key === "),s("span",{class:"hljs-title class_"},"Symbol"),l("."),s("span",{class:"hljs-property"},"unscopables"),l(") "),s("span",{class:"hljs-keyword"},"return"),l(),s("span",{class:"hljs-literal"},"undefined"),l(`
  `),s("span",{class:"hljs-keyword"},"return"),l(` target[key]
} 
`)])],-1),s("p",null,[l("这样一来，只会为每个沙箱对象新建一次 "),s("code",null,"Proxy"),l(" 对象。")],-1),s("h3",null,"最后一点",-1),s("p",null,[l("上面的 "),s("code",null,"compileCode()"),l(" 例子仅 19 行代码，已经是一个可以工作的沙箱代码求值工具。如果有兴趣看看 nx-compile 的完整代码，可以访问 "),s("a",{href:"https://github.com/RisingStack/nx-compile",target:"_blank",rel:"noopener"},"Github 仓库"),l("。")],-1),s("p",null,[l("除解释代码求值外，本章的主要目的是展示一些 ES6 新特性，用它们替代原有方式。贯穿整个例子，我试图展示了 "),s("code",null,"Proxy"),l(" 和 "),s("code",null,"Symbol"),l(" 的强大力量。")],-1),s("h2",null,"写在最后",-1),s("p",null,[l("如果对 NX 框架感兴趣，请访问 "),s("a",{href:"http://nx-framework.com/",target:"_blank",rel:"noopener"},"主页"),l("。胆大的读者还可以在 Github 上查看 "),s("a",{href:"https://github.com/RisingStack/nx-framework",target:"_blank",rel:"noopener"},"NX 源码"),l(" 和 "),s("a",{href:"https://github.com/RisingStack/nx-observe",target:"_blank",rel:"noopener"},"nx-observe 源码"),l("。")],-1),s("p",null,[l("希望你喜欢这篇文章。下一章我们将讨论 "),s("a",{href:"https://blog.risingstack.com/writing-a-javascript-framework-data-binding-dirty-checking/",target:"_blank",rel:"noopener"},"数据绑定"),l("。")],-1)])]),_:1})}}};export{h as default};
